#Hamiltonian cycles are a graph theoretic concept. A HC touches every other vertex exactly once,
    and ends at the vertex where it began. The traveling salesman problem is an attempt to find
    the shortest HC. The traveling salesman problem is an NP-Hard problem.

1.must find the most efficient way to store a graph.
    -store as tuples with vertex and its associated edges?
    -store as edges with their associated weights? if so, will need to form array with list of all edges in order to keep track of them. would be challenging because edge "AB" would be the same as edge "BA" and would be difficult for code to recognize. 
    -nested dictionaries?
    -store as table with a.vertex, b. associated edges, and c. associated weights? but how to deal with redundancies if vertex has several edges? and edges must somehow also relate within the table back to their associated weights
    -need a method that requires little to no parsing of strings.
    -cannot use an array, as some Ith/Jth spaces will be unused for a graph which is not complete.

2. algo? utilize preexisting ones? make new one?
    -use greedy algorithm, but iterate to optimize? if greedy algo is used, data must be stored as vertices--unless begin with edge rather than vertex??
    -begin with lowest weighted edge?
    -begin with hightest-connected vertex?
    --how to avoid halting if two vertices have the same number of edges?
    -how to represent the final cycle? as a string?
   
3. what if no cycle exists? return "no HC exists"
    -do we want the next best thing?
    
4. further down the road:
    -how to iterate in order to optimize, if several HC's exist within a graph?
    -if no HC exists, create option to find the next best thing
    -create GUI to make inputting data easier
    -build in relevant theorems to weed out graphs which don't contain HC's.
